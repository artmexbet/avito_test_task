// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch.go

package queries

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const addUsers = `-- name: AddUsers :batchone
INSERT INTO users (id, username, team_name, is_active)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE SET username   = EXCLUDED.username,
                               team_name  = EXCLUDED.team_name,
                               is_active  = EXCLUDED.is_active,
                               updated_at = CURRENT_TIMESTAMP
RETURNING id, username, team_name, is_active, created_at, updated_at
`

type AddUsersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type AddUsersParams struct {
	ID       string
	Username string
	TeamName string
	IsActive bool
}

func (q *Queries) AddUsers(ctx context.Context, arg []AddUsersParams) *AddUsersBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.Username,
			a.TeamName,
			a.IsActive,
		}
		batch.Queue(addUsers, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &AddUsersBatchResults{br, len(arg), false}
}

func (b *AddUsersBatchResults) QueryRow(f func(int, User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i User
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Username,
			&i.TeamName,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *AddUsersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const assignReviewerToPullRequest = `-- name: AssignReviewerToPullRequest :batchone
INSERT INTO pull_requests_reviewers (pull_request_id, reviewer_id)
VALUES ($1, $2)
ON CONFLICT (pull_request_id, reviewer_id) DO NOTHING
RETURNING pull_request_id, reviewer_id, assigned_at
`

type AssignReviewerToPullRequestBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type AssignReviewerToPullRequestParams struct {
	PullRequestID string
	ReviewerID    string
}

func (q *Queries) AssignReviewerToPullRequest(ctx context.Context, arg []AssignReviewerToPullRequestParams) *AssignReviewerToPullRequestBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.PullRequestID,
			a.ReviewerID,
		}
		batch.Queue(assignReviewerToPullRequest, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &AssignReviewerToPullRequestBatchResults{br, len(arg), false}
}

func (b *AssignReviewerToPullRequestBatchResults) QueryRow(f func(int, PullRequestsReviewer, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i PullRequestsReviewer
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&i.PullRequestID, &i.ReviewerID, &i.AssignedAt)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *AssignReviewerToPullRequestBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchExistsUserByID = `-- name: BatchExistsUserByID :batchone
SELECT EXISTS (SELECT 1
               FROM users
               WHERE id = $1) AS "exists"
`

type BatchExistsUserByIDBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) BatchExistsUserByID(ctx context.Context, id []string) *BatchExistsUserByIDBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(batchExistsUserByID, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchExistsUserByIDBatchResults{br, len(id), false}
}

func (b *BatchExistsUserByIDBatchResults) QueryRow(f func(int, bool, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var exists bool
		if b.closed {
			if f != nil {
				f(t, exists, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&exists)
		if f != nil {
			f(t, exists, err)
		}
	}
}

func (b *BatchExistsUserByIDBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
