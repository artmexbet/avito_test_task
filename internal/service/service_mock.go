// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package service

import (
	"context"

	"github.com/artmexbet/avito_test_task/internal/domain"
	mock "github.com/stretchr/testify/mock"
)

// newMockiPullRequestRepository creates a new instance of mockiPullRequestRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockiPullRequestRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockiPullRequestRepository {
	mock := &mockiPullRequestRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockiPullRequestRepository is an autogenerated mock type for the iPullRequestRepository type
type mockiPullRequestRepository struct {
	mock.Mock
}

type mockiPullRequestRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *mockiPullRequestRepository) EXPECT() *mockiPullRequestRepository_Expecter {
	return &mockiPullRequestRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type mockiPullRequestRepository
func (_mock *mockiPullRequestRepository) Create(ctx context.Context, pr domain.PullRequest) (domain.PullRequest, error) {
	ret := _mock.Called(ctx, pr)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 domain.PullRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.PullRequest) (domain.PullRequest, error)); ok {
		return returnFunc(ctx, pr)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.PullRequest) domain.PullRequest); ok {
		r0 = returnFunc(ctx, pr)
	} else {
		r0 = ret.Get(0).(domain.PullRequest)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.PullRequest) error); ok {
		r1 = returnFunc(ctx, pr)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPullRequestRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type mockiPullRequestRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - pr domain.PullRequest
func (_e *mockiPullRequestRepository_Expecter) Create(ctx interface{}, pr interface{}) *mockiPullRequestRepository_Create_Call {
	return &mockiPullRequestRepository_Create_Call{Call: _e.mock.On("Create", ctx, pr)}
}

func (_c *mockiPullRequestRepository_Create_Call) Run(run func(ctx context.Context, pr domain.PullRequest)) *mockiPullRequestRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.PullRequest
		if args[1] != nil {
			arg1 = args[1].(domain.PullRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPullRequestRepository_Create_Call) Return(pullRequest domain.PullRequest, err error) *mockiPullRequestRepository_Create_Call {
	_c.Call.Return(pullRequest, err)
	return _c
}

func (_c *mockiPullRequestRepository_Create_Call) RunAndReturn(run func(ctx context.Context, pr domain.PullRequest) (domain.PullRequest, error)) *mockiPullRequestRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type mockiPullRequestRepository
func (_mock *mockiPullRequestRepository) Exists(ctx context.Context, prID string) (bool, error) {
	ret := _mock.Called(ctx, prID)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, prID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, prID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, prID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPullRequestRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type mockiPullRequestRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - prID string
func (_e *mockiPullRequestRepository_Expecter) Exists(ctx interface{}, prID interface{}) *mockiPullRequestRepository_Exists_Call {
	return &mockiPullRequestRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, prID)}
}

func (_c *mockiPullRequestRepository_Exists_Call) Run(run func(ctx context.Context, prID string)) *mockiPullRequestRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPullRequestRepository_Exists_Call) Return(b bool, err error) *mockiPullRequestRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mockiPullRequestRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, prID string) (bool, error)) *mockiPullRequestRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type mockiPullRequestRepository
func (_mock *mockiPullRequestRepository) GetByID(ctx context.Context, prID string) (domain.PullRequest, error) {
	ret := _mock.Called(ctx, prID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 domain.PullRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (domain.PullRequest, error)); ok {
		return returnFunc(ctx, prID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) domain.PullRequest); ok {
		r0 = returnFunc(ctx, prID)
	} else {
		r0 = ret.Get(0).(domain.PullRequest)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, prID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPullRequestRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type mockiPullRequestRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - prID string
func (_e *mockiPullRequestRepository_Expecter) GetByID(ctx interface{}, prID interface{}) *mockiPullRequestRepository_GetByID_Call {
	return &mockiPullRequestRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, prID)}
}

func (_c *mockiPullRequestRepository_GetByID_Call) Run(run func(ctx context.Context, prID string)) *mockiPullRequestRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPullRequestRepository_GetByID_Call) Return(pullRequest domain.PullRequest, err error) *mockiPullRequestRepository_GetByID_Call {
	_c.Call.Return(pullRequest, err)
	return _c
}

func (_c *mockiPullRequestRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, prID string) (domain.PullRequest, error)) *mockiPullRequestRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// Merge provides a mock function for the type mockiPullRequestRepository
func (_mock *mockiPullRequestRepository) Merge(ctx context.Context, prID string) (domain.PullRequest, error) {
	ret := _mock.Called(ctx, prID)

	if len(ret) == 0 {
		panic("no return value specified for Merge")
	}

	var r0 domain.PullRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (domain.PullRequest, error)); ok {
		return returnFunc(ctx, prID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) domain.PullRequest); ok {
		r0 = returnFunc(ctx, prID)
	} else {
		r0 = ret.Get(0).(domain.PullRequest)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, prID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPullRequestRepository_Merge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Merge'
type mockiPullRequestRepository_Merge_Call struct {
	*mock.Call
}

// Merge is a helper method to define mock.On call
//   - ctx context.Context
//   - prID string
func (_e *mockiPullRequestRepository_Expecter) Merge(ctx interface{}, prID interface{}) *mockiPullRequestRepository_Merge_Call {
	return &mockiPullRequestRepository_Merge_Call{Call: _e.mock.On("Merge", ctx, prID)}
}

func (_c *mockiPullRequestRepository_Merge_Call) Run(run func(ctx context.Context, prID string)) *mockiPullRequestRepository_Merge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPullRequestRepository_Merge_Call) Return(pullRequest domain.PullRequest, err error) *mockiPullRequestRepository_Merge_Call {
	_c.Call.Return(pullRequest, err)
	return _c
}

func (_c *mockiPullRequestRepository_Merge_Call) RunAndReturn(run func(ctx context.Context, prID string) (domain.PullRequest, error)) *mockiPullRequestRepository_Merge_Call {
	_c.Call.Return(run)
	return _c
}

// newMockiReviewRepository creates a new instance of mockiReviewRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockiReviewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockiReviewRepository {
	mock := &mockiReviewRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockiReviewRepository is an autogenerated mock type for the iReviewRepository type
type mockiReviewRepository struct {
	mock.Mock
}

type mockiReviewRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *mockiReviewRepository) EXPECT() *mockiReviewRepository_Expecter {
	return &mockiReviewRepository_Expecter{mock: &_m.Mock}
}

// AssignToPR provides a mock function for the type mockiReviewRepository
func (_mock *mockiReviewRepository) AssignToPR(ctx context.Context, prID string, reviewerIDs []string) error {
	ret := _mock.Called(ctx, prID, reviewerIDs)

	if len(ret) == 0 {
		panic("no return value specified for AssignToPR")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = returnFunc(ctx, prID, reviewerIDs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mockiReviewRepository_AssignToPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignToPR'
type mockiReviewRepository_AssignToPR_Call struct {
	*mock.Call
}

// AssignToPR is a helper method to define mock.On call
//   - ctx context.Context
//   - prID string
//   - reviewerIDs []string
func (_e *mockiReviewRepository_Expecter) AssignToPR(ctx interface{}, prID interface{}, reviewerIDs interface{}) *mockiReviewRepository_AssignToPR_Call {
	return &mockiReviewRepository_AssignToPR_Call{Call: _e.mock.On("AssignToPR", ctx, prID, reviewerIDs)}
}

func (_c *mockiReviewRepository_AssignToPR_Call) Run(run func(ctx context.Context, prID string, reviewerIDs []string)) *mockiReviewRepository_AssignToPR_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mockiReviewRepository_AssignToPR_Call) Return(err error) *mockiReviewRepository_AssignToPR_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mockiReviewRepository_AssignToPR_Call) RunAndReturn(run func(ctx context.Context, prID string, reviewerIDs []string) error) *mockiReviewRepository_AssignToPR_Call {
	_c.Call.Return(run)
	return _c
}

// GetByPRID provides a mock function for the type mockiReviewRepository
func (_mock *mockiReviewRepository) GetByPRID(ctx context.Context, prID string) ([]domain.User, error) {
	ret := _mock.Called(ctx, prID)

	if len(ret) == 0 {
		panic("no return value specified for GetByPRID")
	}

	var r0 []domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]domain.User, error)); ok {
		return returnFunc(ctx, prID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []domain.User); ok {
		r0 = returnFunc(ctx, prID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, prID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiReviewRepository_GetByPRID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByPRID'
type mockiReviewRepository_GetByPRID_Call struct {
	*mock.Call
}

// GetByPRID is a helper method to define mock.On call
//   - ctx context.Context
//   - prID string
func (_e *mockiReviewRepository_Expecter) GetByPRID(ctx interface{}, prID interface{}) *mockiReviewRepository_GetByPRID_Call {
	return &mockiReviewRepository_GetByPRID_Call{Call: _e.mock.On("GetByPRID", ctx, prID)}
}

func (_c *mockiReviewRepository_GetByPRID_Call) Run(run func(ctx context.Context, prID string)) *mockiReviewRepository_GetByPRID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiReviewRepository_GetByPRID_Call) Return(users []domain.User, err error) *mockiReviewRepository_GetByPRID_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *mockiReviewRepository_GetByPRID_Call) RunAndReturn(run func(ctx context.Context, prID string) ([]domain.User, error)) *mockiReviewRepository_GetByPRID_Call {
	_c.Call.Return(run)
	return _c
}

// GetReviewingPR provides a mock function for the type mockiReviewRepository
func (_mock *mockiReviewRepository) GetReviewingPR(ctx context.Context, userID string) ([]domain.PullRequest, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetReviewingPR")
	}

	var r0 []domain.PullRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]domain.PullRequest, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []domain.PullRequest); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PullRequest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiReviewRepository_GetReviewingPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReviewingPR'
type mockiReviewRepository_GetReviewingPR_Call struct {
	*mock.Call
}

// GetReviewingPR is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *mockiReviewRepository_Expecter) GetReviewingPR(ctx interface{}, userID interface{}) *mockiReviewRepository_GetReviewingPR_Call {
	return &mockiReviewRepository_GetReviewingPR_Call{Call: _e.mock.On("GetReviewingPR", ctx, userID)}
}

func (_c *mockiReviewRepository_GetReviewingPR_Call) Run(run func(ctx context.Context, userID string)) *mockiReviewRepository_GetReviewingPR_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiReviewRepository_GetReviewingPR_Call) Return(pullRequests []domain.PullRequest, err error) *mockiReviewRepository_GetReviewingPR_Call {
	_c.Call.Return(pullRequests, err)
	return _c
}

func (_c *mockiReviewRepository_GetReviewingPR_Call) RunAndReturn(run func(ctx context.Context, userID string) ([]domain.PullRequest, error)) *mockiReviewRepository_GetReviewingPR_Call {
	_c.Call.Return(run)
	return _c
}

// Reassign provides a mock function for the type mockiReviewRepository
func (_mock *mockiReviewRepository) Reassign(ctx context.Context, prID string, newReviewerID string, oldReviewerID string) error {
	ret := _mock.Called(ctx, prID, newReviewerID, oldReviewerID)

	if len(ret) == 0 {
		panic("no return value specified for Reassign")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, prID, newReviewerID, oldReviewerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// mockiReviewRepository_Reassign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reassign'
type mockiReviewRepository_Reassign_Call struct {
	*mock.Call
}

// Reassign is a helper method to define mock.On call
//   - ctx context.Context
//   - prID string
//   - newReviewerID string
//   - oldReviewerID string
func (_e *mockiReviewRepository_Expecter) Reassign(ctx interface{}, prID interface{}, newReviewerID interface{}, oldReviewerID interface{}) *mockiReviewRepository_Reassign_Call {
	return &mockiReviewRepository_Reassign_Call{Call: _e.mock.On("Reassign", ctx, prID, newReviewerID, oldReviewerID)}
}

func (_c *mockiReviewRepository_Reassign_Call) Run(run func(ctx context.Context, prID string, newReviewerID string, oldReviewerID string)) *mockiReviewRepository_Reassign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockiReviewRepository_Reassign_Call) Return(err error) *mockiReviewRepository_Reassign_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *mockiReviewRepository_Reassign_Call) RunAndReturn(run func(ctx context.Context, prID string, newReviewerID string, oldReviewerID string) error) *mockiReviewRepository_Reassign_Call {
	_c.Call.Return(run)
	return _c
}

// newMockiPRUserRepository creates a new instance of mockiPRUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockiPRUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockiPRUserRepository {
	mock := &mockiPRUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockiPRUserRepository is an autogenerated mock type for the iPRUserRepository type
type mockiPRUserRepository struct {
	mock.Mock
}

type mockiPRUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *mockiPRUserRepository) EXPECT() *mockiPRUserRepository_Expecter {
	return &mockiPRUserRepository_Expecter{mock: &_m.Mock}
}

// ExistsByID provides a mock function for the type mockiPRUserRepository
func (_mock *mockiPRUserRepository) ExistsByID(ctx context.Context, userID string) (bool, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsByID")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPRUserRepository_ExistsByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsByID'
type mockiPRUserRepository_ExistsByID_Call struct {
	*mock.Call
}

// ExistsByID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *mockiPRUserRepository_Expecter) ExistsByID(ctx interface{}, userID interface{}) *mockiPRUserRepository_ExistsByID_Call {
	return &mockiPRUserRepository_ExistsByID_Call{Call: _e.mock.On("ExistsByID", ctx, userID)}
}

func (_c *mockiPRUserRepository_ExistsByID_Call) Run(run func(ctx context.Context, userID string)) *mockiPRUserRepository_ExistsByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPRUserRepository_ExistsByID_Call) Return(b bool, err error) *mockiPRUserRepository_ExistsByID_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mockiPRUserRepository_ExistsByID_Call) RunAndReturn(run func(ctx context.Context, userID string) (bool, error)) *mockiPRUserRepository_ExistsByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveByTeamName provides a mock function for the type mockiPRUserRepository
func (_mock *mockiPRUserRepository) GetActiveByTeamName(ctx context.Context, teamName string) ([]domain.User, error) {
	ret := _mock.Called(ctx, teamName)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveByTeamName")
	}

	var r0 []domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]domain.User, error)); ok {
		return returnFunc(ctx, teamName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []domain.User); ok {
		r0 = returnFunc(ctx, teamName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, teamName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPRUserRepository_GetActiveByTeamName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveByTeamName'
type mockiPRUserRepository_GetActiveByTeamName_Call struct {
	*mock.Call
}

// GetActiveByTeamName is a helper method to define mock.On call
//   - ctx context.Context
//   - teamName string
func (_e *mockiPRUserRepository_Expecter) GetActiveByTeamName(ctx interface{}, teamName interface{}) *mockiPRUserRepository_GetActiveByTeamName_Call {
	return &mockiPRUserRepository_GetActiveByTeamName_Call{Call: _e.mock.On("GetActiveByTeamName", ctx, teamName)}
}

func (_c *mockiPRUserRepository_GetActiveByTeamName_Call) Run(run func(ctx context.Context, teamName string)) *mockiPRUserRepository_GetActiveByTeamName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPRUserRepository_GetActiveByTeamName_Call) Return(users []domain.User, err error) *mockiPRUserRepository_GetActiveByTeamName_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *mockiPRUserRepository_GetActiveByTeamName_Call) RunAndReturn(run func(ctx context.Context, teamName string) ([]domain.User, error)) *mockiPRUserRepository_GetActiveByTeamName_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type mockiPRUserRepository
func (_mock *mockiPRUserRepository) GetByID(ctx context.Context, userID string) (domain.User, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (domain.User, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) domain.User); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Get(0).(domain.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiPRUserRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type mockiPRUserRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *mockiPRUserRepository_Expecter) GetByID(ctx interface{}, userID interface{}) *mockiPRUserRepository_GetByID_Call {
	return &mockiPRUserRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, userID)}
}

func (_c *mockiPRUserRepository_GetByID_Call) Run(run func(ctx context.Context, userID string)) *mockiPRUserRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiPRUserRepository_GetByID_Call) Return(user domain.User, err error) *mockiPRUserRepository_GetByID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *mockiPRUserRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, userID string) (domain.User, error)) *mockiPRUserRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// newMockiTeamRepository creates a new instance of mockiTeamRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockiTeamRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockiTeamRepository {
	mock := &mockiTeamRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockiTeamRepository is an autogenerated mock type for the iTeamRepository type
type mockiTeamRepository struct {
	mock.Mock
}

type mockiTeamRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *mockiTeamRepository) EXPECT() *mockiTeamRepository_Expecter {
	return &mockiTeamRepository_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type mockiTeamRepository
func (_mock *mockiTeamRepository) Add(ctx context.Context, team domain.Team) (domain.Team, error) {
	ret := _mock.Called(ctx, team)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 domain.Team
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Team) (domain.Team, error)); ok {
		return returnFunc(ctx, team)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Team) domain.Team); ok {
		r0 = returnFunc(ctx, team)
	} else {
		r0 = ret.Get(0).(domain.Team)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.Team) error); ok {
		r1 = returnFunc(ctx, team)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiTeamRepository_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type mockiTeamRepository_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - ctx context.Context
//   - team domain.Team
func (_e *mockiTeamRepository_Expecter) Add(ctx interface{}, team interface{}) *mockiTeamRepository_Add_Call {
	return &mockiTeamRepository_Add_Call{Call: _e.mock.On("Add", ctx, team)}
}

func (_c *mockiTeamRepository_Add_Call) Run(run func(ctx context.Context, team domain.Team)) *mockiTeamRepository_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.Team
		if args[1] != nil {
			arg1 = args[1].(domain.Team)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiTeamRepository_Add_Call) Return(team1 domain.Team, err error) *mockiTeamRepository_Add_Call {
	_c.Call.Return(team1, err)
	return _c
}

func (_c *mockiTeamRepository_Add_Call) RunAndReturn(run func(ctx context.Context, team domain.Team) (domain.Team, error)) *mockiTeamRepository_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type mockiTeamRepository
func (_mock *mockiTeamRepository) Exists(ctx context.Context, teamName string) (bool, error) {
	ret := _mock.Called(ctx, teamName)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, teamName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, teamName)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, teamName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiTeamRepository_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type mockiTeamRepository_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - teamName string
func (_e *mockiTeamRepository_Expecter) Exists(ctx interface{}, teamName interface{}) *mockiTeamRepository_Exists_Call {
	return &mockiTeamRepository_Exists_Call{Call: _e.mock.On("Exists", ctx, teamName)}
}

func (_c *mockiTeamRepository_Exists_Call) Run(run func(ctx context.Context, teamName string)) *mockiTeamRepository_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiTeamRepository_Exists_Call) Return(b bool, err error) *mockiTeamRepository_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mockiTeamRepository_Exists_Call) RunAndReturn(run func(ctx context.Context, teamName string) (bool, error)) *mockiTeamRepository_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type mockiTeamRepository
func (_mock *mockiTeamRepository) Get(ctx context.Context, teamName string) (domain.Team, error) {
	ret := _mock.Called(ctx, teamName)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 domain.Team
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (domain.Team, error)); ok {
		return returnFunc(ctx, teamName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) domain.Team); ok {
		r0 = returnFunc(ctx, teamName)
	} else {
		r0 = ret.Get(0).(domain.Team)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, teamName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiTeamRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type mockiTeamRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - teamName string
func (_e *mockiTeamRepository_Expecter) Get(ctx interface{}, teamName interface{}) *mockiTeamRepository_Get_Call {
	return &mockiTeamRepository_Get_Call{Call: _e.mock.On("Get", ctx, teamName)}
}

func (_c *mockiTeamRepository_Get_Call) Run(run func(ctx context.Context, teamName string)) *mockiTeamRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiTeamRepository_Get_Call) Return(team domain.Team, err error) *mockiTeamRepository_Get_Call {
	_c.Call.Return(team, err)
	return _c
}

func (_c *mockiTeamRepository_Get_Call) RunAndReturn(run func(ctx context.Context, teamName string) (domain.Team, error)) *mockiTeamRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// newMockiTeamUserRepository creates a new instance of mockiTeamUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockiTeamUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockiTeamUserRepository {
	mock := &mockiTeamUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockiTeamUserRepository is an autogenerated mock type for the iTeamUserRepository type
type mockiTeamUserRepository struct {
	mock.Mock
}

type mockiTeamUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *mockiTeamUserRepository) EXPECT() *mockiTeamUserRepository_Expecter {
	return &mockiTeamUserRepository_Expecter{mock: &_m.Mock}
}

// Add provides a mock function for the type mockiTeamUserRepository
func (_mock *mockiTeamUserRepository) Add(ctx context.Context, users []domain.User) ([]domain.User, error) {
	ret := _mock.Called(ctx, users)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 []domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []domain.User) ([]domain.User, error)); ok {
		return returnFunc(ctx, users)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []domain.User) []domain.User); ok {
		r0 = returnFunc(ctx, users)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []domain.User) error); ok {
		r1 = returnFunc(ctx, users)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiTeamUserRepository_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type mockiTeamUserRepository_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - ctx context.Context
//   - users []domain.User
func (_e *mockiTeamUserRepository_Expecter) Add(ctx interface{}, users interface{}) *mockiTeamUserRepository_Add_Call {
	return &mockiTeamUserRepository_Add_Call{Call: _e.mock.On("Add", ctx, users)}
}

func (_c *mockiTeamUserRepository_Add_Call) Run(run func(ctx context.Context, users []domain.User)) *mockiTeamUserRepository_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []domain.User
		if args[1] != nil {
			arg1 = args[1].([]domain.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiTeamUserRepository_Add_Call) Return(users1 []domain.User, err error) *mockiTeamUserRepository_Add_Call {
	_c.Call.Return(users1, err)
	return _c
}

func (_c *mockiTeamUserRepository_Add_Call) RunAndReturn(run func(ctx context.Context, users []domain.User) ([]domain.User, error)) *mockiTeamUserRepository_Add_Call {
	_c.Call.Return(run)
	return _c
}

// BatchExistsByID provides a mock function for the type mockiTeamUserRepository
func (_mock *mockiTeamUserRepository) BatchExistsByID(ctx context.Context, users []domain.User) map[domain.User]bool {
	ret := _mock.Called(ctx, users)

	if len(ret) == 0 {
		panic("no return value specified for BatchExistsByID")
	}

	var r0 map[domain.User]bool
	if returnFunc, ok := ret.Get(0).(func(context.Context, []domain.User) map[domain.User]bool); ok {
		r0 = returnFunc(ctx, users)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[domain.User]bool)
		}
	}
	return r0
}

// mockiTeamUserRepository_BatchExistsByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchExistsByID'
type mockiTeamUserRepository_BatchExistsByID_Call struct {
	*mock.Call
}

// BatchExistsByID is a helper method to define mock.On call
//   - ctx context.Context
//   - users []domain.User
func (_e *mockiTeamUserRepository_Expecter) BatchExistsByID(ctx interface{}, users interface{}) *mockiTeamUserRepository_BatchExistsByID_Call {
	return &mockiTeamUserRepository_BatchExistsByID_Call{Call: _e.mock.On("BatchExistsByID", ctx, users)}
}

func (_c *mockiTeamUserRepository_BatchExistsByID_Call) Run(run func(ctx context.Context, users []domain.User)) *mockiTeamUserRepository_BatchExistsByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []domain.User
		if args[1] != nil {
			arg1 = args[1].([]domain.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiTeamUserRepository_BatchExistsByID_Call) Return(userToBool map[domain.User]bool) *mockiTeamUserRepository_BatchExistsByID_Call {
	_c.Call.Return(userToBool)
	return _c
}

func (_c *mockiTeamUserRepository_BatchExistsByID_Call) RunAndReturn(run func(ctx context.Context, users []domain.User) map[domain.User]bool) *mockiTeamUserRepository_BatchExistsByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByTeamName provides a mock function for the type mockiTeamUserRepository
func (_mock *mockiTeamUserRepository) GetByTeamName(ctx context.Context, teamName string) ([]domain.User, error) {
	ret := _mock.Called(ctx, teamName)

	if len(ret) == 0 {
		panic("no return value specified for GetByTeamName")
	}

	var r0 []domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]domain.User, error)); ok {
		return returnFunc(ctx, teamName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []domain.User); ok {
		r0 = returnFunc(ctx, teamName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, teamName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiTeamUserRepository_GetByTeamName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByTeamName'
type mockiTeamUserRepository_GetByTeamName_Call struct {
	*mock.Call
}

// GetByTeamName is a helper method to define mock.On call
//   - ctx context.Context
//   - teamName string
func (_e *mockiTeamUserRepository_Expecter) GetByTeamName(ctx interface{}, teamName interface{}) *mockiTeamUserRepository_GetByTeamName_Call {
	return &mockiTeamUserRepository_GetByTeamName_Call{Call: _e.mock.On("GetByTeamName", ctx, teamName)}
}

func (_c *mockiTeamUserRepository_GetByTeamName_Call) Run(run func(ctx context.Context, teamName string)) *mockiTeamUserRepository_GetByTeamName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiTeamUserRepository_GetByTeamName_Call) Return(users []domain.User, err error) *mockiTeamUserRepository_GetByTeamName_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *mockiTeamUserRepository_GetByTeamName_Call) RunAndReturn(run func(ctx context.Context, teamName string) ([]domain.User, error)) *mockiTeamUserRepository_GetByTeamName_Call {
	_c.Call.Return(run)
	return _c
}

// newMockiUserRepository creates a new instance of mockiUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockiUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockiUserRepository {
	mock := &mockiUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockiUserRepository is an autogenerated mock type for the iUserRepository type
type mockiUserRepository struct {
	mock.Mock
}

type mockiUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *mockiUserRepository) EXPECT() *mockiUserRepository_Expecter {
	return &mockiUserRepository_Expecter{mock: &_m.Mock}
}

// ExistsByID provides a mock function for the type mockiUserRepository
func (_mock *mockiUserRepository) ExistsByID(ctx context.Context, userID string) (bool, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsByID")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiUserRepository_ExistsByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsByID'
type mockiUserRepository_ExistsByID_Call struct {
	*mock.Call
}

// ExistsByID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *mockiUserRepository_Expecter) ExistsByID(ctx interface{}, userID interface{}) *mockiUserRepository_ExistsByID_Call {
	return &mockiUserRepository_ExistsByID_Call{Call: _e.mock.On("ExistsByID", ctx, userID)}
}

func (_c *mockiUserRepository_ExistsByID_Call) Run(run func(ctx context.Context, userID string)) *mockiUserRepository_ExistsByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockiUserRepository_ExistsByID_Call) Return(b bool, err error) *mockiUserRepository_ExistsByID_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *mockiUserRepository_ExistsByID_Call) RunAndReturn(run func(ctx context.Context, userID string) (bool, error)) *mockiUserRepository_ExistsByID_Call {
	_c.Call.Return(run)
	return _c
}

// SetIsActive provides a mock function for the type mockiUserRepository
func (_mock *mockiUserRepository) SetIsActive(ctx context.Context, userID string, isActive bool) (domain.User, error) {
	ret := _mock.Called(ctx, userID, isActive)

	if len(ret) == 0 {
		panic("no return value specified for SetIsActive")
	}

	var r0 domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) (domain.User, error)); ok {
		return returnFunc(ctx, userID, isActive)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) domain.User); ok {
		r0 = returnFunc(ctx, userID, isActive)
	} else {
		r0 = ret.Get(0).(domain.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = returnFunc(ctx, userID, isActive)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// mockiUserRepository_SetIsActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIsActive'
type mockiUserRepository_SetIsActive_Call struct {
	*mock.Call
}

// SetIsActive is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - isActive bool
func (_e *mockiUserRepository_Expecter) SetIsActive(ctx interface{}, userID interface{}, isActive interface{}) *mockiUserRepository_SetIsActive_Call {
	return &mockiUserRepository_SetIsActive_Call{Call: _e.mock.On("SetIsActive", ctx, userID, isActive)}
}

func (_c *mockiUserRepository_SetIsActive_Call) Run(run func(ctx context.Context, userID string, isActive bool)) *mockiUserRepository_SetIsActive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mockiUserRepository_SetIsActive_Call) Return(user domain.User, err error) *mockiUserRepository_SetIsActive_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *mockiUserRepository_SetIsActive_Call) RunAndReturn(run func(ctx context.Context, userID string, isActive bool) (domain.User, error)) *mockiUserRepository_SetIsActive_Call {
	_c.Call.Return(run)
	return _c
}
